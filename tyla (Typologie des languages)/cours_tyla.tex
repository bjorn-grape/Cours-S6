\documentclass[a4paper,11pt]{article}

% Standart.
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[french]{babel}
\usepackage{eurosym}

% Page format.
\usepackage{geometry}
\geometry{top=2cm, bottom=2cm, left=1cm, right=1cm}

% Figures.
\usepackage{graphicx}
\graphicspath{{resources/}}
\usepackage{float}
\usepackage{array}
\usepackage{tikz}

% Math and chemistry.
%\usepackage{chemist}
%\usepackage{siunitx}
%\usepackage{numprint}
%\usepackage{amsmath}
%\usepackage{amssymb}
%\usepackage{stmaryrd}

% Links. Should be loaded last.
\usepackage{hyperref}
\hypersetup{colorlinks=true,
            linkcolor=blue,
            filecolor=magenta,
            urlcolor=cyan,
            citecolor=blue}


% Useful environment
\newenvironment*{dummyenvironment}{}{}

% Custom commands
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\der}{\,\mathrm{d}}
\newcommand{\e}{\mathrm{e}}
\newcommand{\ti}{\cdot}

\title{Typologie des languages}
\author{Étienne RENAULT}
\date{20 mars 2018}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Historique}

\subsection{Introduction}

Most of the course can be found here:
\url{https://www.lrde.epita.fr/~tiger/lecture-notes/slides/tyla/}

On a envie d'apprendre les noms des créateurs des langages pour le partiel.

\subsection{Chronologie}

Vérifier les dates!

\begin{itemize}

\item Première machine pour calculer: abaque. (addition, soustraction)

\item 1643: Pascaline, première machine à calculer mécanique. (addition,
  soustraction)

\item 1673: Première machine avec multiplications et divisions.

\item 1725: Basille Bouchon, mécanisation d'un métier à tisser. Transposition
  d'un programme sur un support. La machine n'a pas duré faute de fragilité.

\item 1780: Découverte de l'électricité par Benjamin Franklin. (Avec cerf-
  volant).

\item 1805: Jacquard fait un métier à tisser complètement automatisé à carte
  perforée   et alimenté à l'électricité.

\item 1833: Babbage: machine analytique. Sortie non-tissu. Sortie sur des roues
  crantées. Ada Lovelace, comtesse, première programmeuse. Elle faisait de la
  science, rare à l'époque. Elle fait de la traduction de sciences pour la
  machine de Babbage.

\item 1876: Téléphone, par Alexander Graham Bell et Elisha Gray (stagiaire).
  Le stagiare fait tomber un truc  (?)

\item 1911: CTRC (ancêtre d'IBM). Doit toquer chez tous les Américains pour
  faire un resencement.
  IBM a construit des machines pour faire le recensement.

\item 1924: IBM prend son nom.

\item 1927: Première démonstration publique d'une télévision.

\item 1936: Premier calculator, le Z1. Konrag Suze. Fait un ordinateur chez
  ses parents. machine détruite par les Allemands pendant la guerre.
  Reconstruite après par le même.

\item 1939: Radio Shack (catalogue).

\item 1939: Conception de l'ABC (Atanasoff-Berry Computer). Ruled the first automatic
  digital computer en 1973. Not programmable, not turing-complete.

\item 1940: Première TV couleur.

\item 1941: Première machine Turing-complète: Zuse's Z3. Basée sur des tubes à
  vide.

\item 1944: March 1. Machine pour de la défense militaire. 12 000 tubes à vide.
  Une chance sur 2 pour qu'un tube à vide avant la fin de l'exécution du
  programme.

\item 1945: Grace Hopper: trouve le premier bug sur le Harvard Mark II.
  Invente aussi le COBOL plus tard.

\item 1946: ENIAC, 18 000 tubes.

\item 1946; Univac

\item 1948: Transistor. (Hyper artisanal).

\item 1949: EDVAC: Première machine pour tester des disques magnétiques.

\item 1949: Binac: Premier ordinateur pour diriger des missiles \textbf{en temps
    réel}.

\item 1949: Le MIT construit la première machine qui joue aux échecs.

\item 1949: Premier ordinateur commercialisé (demi-pièce): Univac II.

\item 1952: RCA développe le Bizmac. Première base de données.

\item 1952: Imprimante à matrice pour l'Univac 1107 dans les années 60.

\item 1953:  Bande magnétiques.

\item 1953: IBM 701. Machine à louer. Addition en 5 cycles, comme maintenant.
  Fortran est créé sur ces machines par John Backus. Révolution. On passe de
  zéros et de uns à une feuille de papier avec variables et commentaires.

\item 1954: Premier OS pour l'IBM 704, un mainframe.

\item 1954: RAND corporation: modèle pour illustrer l'ordinateur en 2004.

\item 1955: Premier groupe d'utilisateur: SHARE (IBM 701).

\item 1955: IBM demande à chaque pays de traduire computer. Jacques Perret: ``ordinateur''.

\item 1957: Film ``Desk Set''. Ressemble aux assistants vocaux actuels.

\item 1959: 8 traîtres. Bossent sur tubes à vide nouvelle génération. Partent
  tous en même temps.

\item 1959: Texas: Premier circuit intégré.

\item 1959: COBOL

\item 1959: IBM 401: 10 000 machines vendues.

\item 1960: Téléphone automatisé.

\item 1961: Premier micro-ordinateur. Fourni avec écran.

\item PDP-1: Space war. Premier jeu vidéo.

\item 1963: Tandy achète Radio Shack. Lancement pour le grand public.

\item 1964: Un étudiant du MIT joue de la musique sur le PDP-1.

\item 1964: CDC 6000. Ordinateur le plus puissant de son époque.

\item 1964: Création du BASIC. Language interprété. Interpréteur écrit en
  Assembleur.

\item CDC: Lance des études d'informatique.

\item 1965: Douglas Engelbart: Créé la première souris. Génie. Première
  démonstation enregistrée.

\item Herb Sutter (gourou du C++). Résume toutes les contributions d'Engelbart.
  A aussi inventé le pattern matching.

\item 1965: IBM 360. Couvrait tous les besoins de l'informaticien.

\item 1965: Premier doctorant en informatique.

\item 1968: Première calculette par Texas et HP.

\item 1968: Fondation d'Intel.

\item 1969: Fondation d'AMD.

\item 1969: IBM intrduit System-3.

\item 1969: Bell Labs arrête MULTICS. Ken Thompson implémente alors UNICS sur un
  PDP/7. (4K mots de 18 bits). Codé en P. Jeu de mots avec Eunuque car sa femme
  était partie.

\item 1970: IBM vend

\item 1971: IBM lance les disquettes.

\item 1971: Intel 4004.

\item 1971: Livres grand public.

\item 1971: Kenbak I. 256 bits de RAM. Pour 750\$. Se branche sur la TV.

\item 1972: Atari lance Pong.

\item 1975: MITS lance l'Altair.

\item 1975: Ouvertue de la première boutique d'ordinateurs.

\item 1975: IBM 5100. Flop.

\item 1976: Z80.

\item 1976: Apple I.

\item 1977: Atari VCS 2600.

\item 1977: Bill Gates arrêté pour avoir grillé un feu rouge.

\item 1977: Apple II.

\item 1977: Apple, Comodore et Tnady commencent à vendre des ordianteurs
  personnels.

\item 1978: Premier demi-million d'ordinateurs vendus.

\item Ouverture de The Source et de Compulab.

\item 1980: Sinclair ZX 80 pour 99\$.

\item 1981: IBM PC 5150. Appel d'offre pour les OS. Prend Microsoft avec QDOS.

\item 1981: Premier ordinateur ``portable''. 25kg. Osborne 1.

\item 1981: Début des interface manager (ancêtre Windows).

\item 1983: Times déclare l'ordinateur le titre de personnalité de l'année.

\item 1983-09-27: Début de GNU par Richard Stallman. Problème d'imprimante Xerox.
  Cause de logiciel propirétaire. Développe GNU.

\item 1984: Lancement du Macintosh.

\item 1985: Windows 1.0. Ils ont juste ajouté la couleur.

\item 2011: Watson bat un être humain à Jeopardy.

\item 2015: AlphaGo bat les meilleurs joueurs de Go.

\item Chanson ``Changing minds'' par le groupe 16 bits.

\item ENIAC

\item The baby: la machine avec laquelle on est allés sur la lune.

\item Ferranti pagasus. Kreftwerk. Ils ont inventé la musique électronique.

\end{itemize}

\section{Une histoire des langages de programmation}

Gros problème: les langages de programmation sont une tour de Babel.

\subsection{Première partie}

\subsubsection{FORTRAN}

John Baccus en a marre de faire de l'octal.

Va voir Watson (IBM, CEO) pour lui demander de faire un langage de
programmation. Va voir le fils du CEO qui lui dit oui.

Ils travaillent sur l'IBM 704. Ils font le langage en 2 ans.

Le présente au père. le vend et fait un flop.

Donc open bar avec correction de problèmes gratuite.

Ils inventent une bonne partie des fonctionnalités actuelles.

De très bonnes performances pour le calcul scientifique.

En C, les digraphes et trigraphes, comme en fortran: .LE. au lieu de <=.

\subsubsection{ALGOL}

Anciennement AIL.

4 objectifs:

\begin{enumerate}

\item Faire un support pour les publications et les revues scientifiques.

\item Doit donc être proche des notations mathématiques.

\item Doit être lisible sans aide

\item Doit être traduisible en code machine.

\end{enumerate}

On a les mêmes droits de partout. Donc compilo pourri et perfs pourries.

A servi pour faire JOVIAL pour programmer des missiles.

A été fait (entre autre) par John Backus, qui a inventé la Backus inner form:

<stmt>::=<ifthenelse>|<unsigned>

On a intérêt à lire cette représentation quand on se lance dans un nouveau
langage.

Plus gros problème: pas d'IO standard.

Intéressant: priorités aux fonctions.

\subsubsection{COBOL}

Fait par Grace Murray Hopper.

Ils ont fait le langage et le compilo en 3 mois. Avec les résultats qu'on
attend.

Surtout pour le buisness.

Imposé par l'armée américaine dans ses contrats.

\subsection{Seconde vague}

\subsubsection{APL}

Illisible mais génial. Besoin d'un clavier spécial.

Ancêtre de Go et R.

\subsubsection{PL/I}

Fourni avec l'IBM 360. Objectif: faire tout.

Et il se démarque avec l'invention de la notion d'exception.

Mais c'est incompatible avec le temps réel.

\

Easter egg:

Pas de mot-clé réservé. On peut nommer des variables ``if''...

Abbréviations non-homogènes...

25 + 1/3 = 5.3333333333333333333333333333...

25 + 01/3 se passe comme prévu...

\subsubsection{BASIC}

Très populaire.

Il doit s'exécuter jusqu'à omber sur une erreur.

\subsubsection{Pascal \& Heirs}

Fin des années 60.

Boucles repeat et until.

Types énumérés.

Type interval.

Garde la structure de l'ALGOL.

Veut les performances de FORTRAN.

\

Va donner Ada. Résultat d'un concours du DoD.

Temps réel et exceptions.

Super opportunités en Ada. Très propre.

\subsection{The final wave}

\subsubsection{K. N. King}

Juste un opportuniste. Prend des photos de partout.

\section{Histoire de l'orienté objet}

\subsection{Early languages}

\subsubsection{Simula}

Turing awards: Prix Nobel de l'informatique.

Permet de faire des thread pour faire varier la vitesse d'exécution des objets
dans une centrale.

Introduit:

Object, class, constructors, inheritance, virtual methods, attribute hiding, etc.

\

Impact:

Smalltalk

Objective-C, Objective-Pascal, Objective-C++, etc. (Problème: lent, Avantage: on
peut avoir des objects sur des machines différentes.)

CLOS (Objectif: dispatch dynamique sur tous les paramètres, basé lisp)

Eiffel

C++

\subsubsection{Smalltalk}

Langage non révolutionnaire, petite échelle.

Tout est objet.

Simple à comprendre. Objectif; faire une tablette pour les enfants.

La seule interface est de passer des messages.

Gros problème de performance.

\

Règles pour décrire le fonctionnement des métaclases de Smalltalk:

\begin{enumerate}

\item Tout est objet.

\item Tout est une instance de classe

\item Toute classe possède une super-classe (contrairement à Java, avec Object,
  par exemple.)

\item Tout fonctionne au travers de passage de messages.

\item Le lookup doit se faire selon la chaîne d'héritage. (Donc pas d'héritage
  multiple.)

\item Chaque classe est une instance d'une méta-classe. (Donc générateur de
  méta-classe pour simplifier la vie car on a besoin de travailler sur les deux
  simultanément).

\item La hiérarchie des méta-classes est parallèle à la hiérarchie des classes.

\item Chaque classe hérite de ``Class''.

\item Chaque méta-classe est une instance de ``Metaclass''.

  \item La méta-classe de ``Metaclass'' est une instance de ``Metaclass''.

\end{enumerate}

\

Donc en C++:

class

struct

interface

\

Intérêt d'une métaclasse: dire comment struct et class se comportent.

\

Voir Squeak, une implémentation moderne de Smalltalk.

Ajouter le schéma de l'héritage de Squeak.

\subsubsection{C++}

Par Stroustrup.

Ajouts:

\begin{itemize}

\item const

\item reference

\item Prototypes

\item Booleans

\item Declaring variables anywhere

\item void

\item inline

\item namespace

\item overloading

\end{itemize}

\subsection{Propriété de l'OO}

Rica Cardelli: Travaille sur le typage.

Pour lui, un bon langage doit avoir ces caractéristiques:

\begin{itemize}

\item Économie de l'exécution

\item Économie de compilation

\item Économie de dévelopement à petite échelle

\item Économie de dévelopement à grande échelle

\item Économie de fonctionnalités

\end{itemize}

\section{Paramètres de fonctions}
Exemples :
\begin{itemize}
  \item Valeur
  \item Référence
  \item Name (Équivalent remplacement par macro dans une fonction uniquement)
\end{itemize}

\subsection{(N)RVO Return value optimization}

C++

g()

std::vector<int> res;

return res;

Le compilateur ne va pas appeler le constructeur par copie pour des raisons de
performance.

\

En revanche, Ada fait des copies à l'appel et au retour. C'est du ``value
result''.

\subsection{Call by name}

On remplace toutes les occurrences des variables par les paramètres de l'appel.

Plus personne le fait: on a les template, maintenant.

\subsection{Default parameters}

Introduit par Ada.

\subsection{Subprograms as arguments}

C++ : lambda, std::function

C: pointer on function

\subsection{Conclusion}

Lire Conception et programmation objet.

Il parle d'Eiffel.

\section{Technologie objet Eiffel}

Bertrand Mayer (MIT)

\subsection{Introduction}

Il y a des classes et des objets.

Closes d'adaptation d'héritage.

\subsection{Des concepts originaux}

Programmation contractuelle.

3 modes de dévelopement (Optimisation, Débug, Production).

\subsection{Les objets}





\end{document}
